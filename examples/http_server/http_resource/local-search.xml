<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>轻量级高并发网络库+httpserver</title>
    <link href="/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93-httpserver/"/>
    <url>/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%93-httpserver/</url>
    
    <content type="html"><![CDATA[<img src="../img/FalconLink/falcon-black.png" width="100%" height="75%"><blockquote><p>本博客部署在两个服务器上，其中一个的 HTTP 服务就是由本文介绍的 FalconLink 提供。你可以通过IP地址 121.4.49.170:8090 尝试访问。 项目地址 <a href="https://github.com/caaatch22/FalconLink">https://github.com/caaatch22/FalconLink</a></p></blockquote><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p><strong>FalconLink</strong>是一个轻量级的高并发网络库。它封装了网络编程套接字API，将其抽象成一个易用，可拓展框架。用户只需通过设置回调函数的形式注入业务逻辑。它同时也具有 HTTP 服务请求与解析的功能。</p><p><img src="../img/FalconLink/falconlink-architecture.png" alt="" /></p><p>上图是FalconLink系统架构的一个简单概括性图示。</p><ul><li>采用<strong>非阻塞socket</strong>配合<strong>边缘触发</strong>，及<em>one loop per thread</em>的主从<code>reactor</code>设计</li><li><code>Acceptor</code> 是专门用于处理接受新用户连接请求的模块。它守候在监听端口。收到请求后建立 <code>Connection</code> 分配给 EventLoop。</li><li>FalconLink 将每个 TCP连接抽象成一个 <code>Connection</code>，一个<code>Connection</code>对应一个连接 socket 套接字。用户可以为每一条Connection注册回调函数。</li><li>每个 <code>EventLoop</code> 都拥有一个 <code>Poller</code>。 <code>Poller</code> 负责监听已连接的套接字，将有事件触发的连接反馈给 <code>EventLoop</code>。</li><li><code>EventLoop</code>是该系统的核心组件, 每个都单独运行在一个线程中. 它从 <code>Poller</code> 中接收到有事件触发的用户连接后, 会获取并执行它们的回调函数.</li><li><code>ThreadPool</code> 线程池管理着系统中有多少个 <code>EventLoop</code> 在运行，并调度线程，防止注册过多线程导致性能下降。</li><li>支持 HTTP(GET,HEAD)请求的解析与回复，支持挂载静态 html 文件（本博客使用FalconLink的 HTTP 服务）</li></ul><h2 id="api"><a class="markdownIt-Anchor" href="#api"></a> API</h2><p>使用falconlink，可以轻易且优雅的在20行内实现一个<code>echo server</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;falconlink.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">falconlink::InetAddr <span class="hljs-title">local_address</span><span class="hljs-params">(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">8090</span>)</span></span>;<br>  <span class="hljs-function">falconlink::Server <span class="hljs-title">echo_server</span><span class="hljs-params">(local_address)</span></span>;<br>  echo_server<br>      .<span class="hljs-built_in">onHandle</span>([&amp;](falconlink::Connection* client_conn) &#123;<br>        <span class="hljs-type">int</span> from_fd = client_conn-&gt;<span class="hljs-built_in">fd</span>();<br>        <span class="hljs-keyword">auto</span> [read, exit] = client_conn-&gt;<span class="hljs-built_in">recv</span>();<br>        <span class="hljs-keyword">if</span> (exit) &#123;<br>          client_conn-&gt;<span class="hljs-built_in">getEventLoop</span>()-&gt;<span class="hljs-built_in">deleteConnection</span>(from_fd);<br>          <span class="hljs-comment">// client_conn ptr is invalid below here, do not touch it again</span><br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 只有以下四行是业务逻辑</span><br>        <span class="hljs-keyword">if</span> (read) &#123;<br>          client_conn-&gt;<span class="hljs-built_in">WriteToWriteBuffer</span>(client_conn-&gt;<span class="hljs-built_in">ReadAsString</span>());<br>          client_conn-&gt;<span class="hljs-built_in">send</span>();<br>          client_conn-&gt;<span class="hljs-built_in">clearReadBuffer</span>();<br>        &#125;<br>        <br>      &#125;)<br>      .<span class="hljs-built_in">start</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="build-test"><a class="markdownIt-Anchor" href="#build-test"></a> Build &amp; Test</h2><p>将代码 clone 到本地，进入主目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo sh ./build_support/pachages.sh<br><br><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br><br>cmake ..  <span class="hljs-comment"># Debug mode by default</span><br><span class="hljs-comment"># or </span><br>cmake -DCMAKE_BUILD_TYPE=Release .. <span class="hljs-comment"># to use release mode</span><br><br>make<br><br><span class="hljs-comment"># test</span><br>make build-tests<br>make <span class="hljs-built_in">test</span><br><br><span class="hljs-comment"># or you can test each file</span><br>make xxx_test<br>./test/xxx_test<br><br></code></pre></td></tr></table></figure><h2 id="http-service"><a class="markdownIt-Anchor" href="#http-service"></a> http service</h2><p>你可以进行使用 falconlink 搭建自己的 http 服务器。<br />在 <code>build</code> 目录下 <code>make http_server</code>，然后运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">./bin/http_server [optional: port default=8090] [optional:directory <br>default=../examples/http_server/http_resource/]<br></code></pre></td></tr></table></figure><p>你可以替换自行<code>http_resource</code>中的文件，并在浏览器中输入<code>localhost:&#123;port&#125;</code>查看</p><h2 id="benchmark"><a class="markdownIt-Anchor" href="#benchmark"></a> Benchmark</h2><p>使用 <code>webbench</code>进行压力测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">make benchmark<br></code></pre></td></tr></table></figure><ul><li><p><strong>硬件</strong>:</p><ul><li>Intel® Xeon® Gold 6148 CPU @ 2.40GHz</li><li>OS:Ubuntu 20.04 LTS,</li><li>4 核 CPU， 16GiB内存， 100GiB磁盘存储。</li></ul></li><li><p><strong>QPS</strong>: <strong>40K</strong></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ComputerNetwork</tag>
      
      <tag>FalconLink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-project3 Query Excution</title>
    <link href="/CMU15445-project3-Query-Execution/"/>
    <url>/CMU15445-project3-Query-Execution/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><blockquote><p>在这次实验写完后，我们已经能使用bustub-shell完成执行 sql 语句了，还是挺有成就感的。同时，TA 为我们准备了<a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">浏览器上的bustub</a> ，方便和我们写的对比调试。你也可以使用 <code>explain</code> 来查看他的优化策略与执行步骤。</p></blockquote><p>这次实验的主要难点在于读代码，理清 bustub 的执行引擎的数据流以及代码中的实现。搞懂了之后各个算子的实现就很简单了（相对 B+树）。</p><p><img src="../img/busTub/query_excution/project-structure.png" alt="" /></p><p>上图是 bustub 的整体架构。</p><h3 id="parser"><a class="markdownIt-Anchor" href="#parser"></a> Parser</h3><p>sql 语句的解析就像其他编程语言一样，同样需要翻译成比较结构化的东西。Parser 阶段会生成一个<em>抽象语法树(AST, Abstract Syntax Tree)</em>。 这并不是数据库核心部分，bustub 直接使用了 PostgreSQL 的 parser 库 libpg_query。</p><h3 id="binder"><a class="markdownIt-Anchor" href="#binder"></a> Binder</h3><p>得到 AST 后，需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.y, table2.x <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> table1.x <span class="hljs-operator">=</span> table2.y;<br></code></pre></td></tr></table></figure><p>其中 <code>SELECT</code> 和 <code>FROM</code> 是关键字，<code>x</code> 和 <code>table1</code> 是标识符。我们可以使用 <code>explain</code> 来看看 <code>binder</code> 层（bustub-shell 未完成时也可以使用 explain）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"> === BINDER ===                                               <br> BoundSelec &#123;                                        <br>   table=BoundJoin &#123; type=Inner, left=BoundBaseTableRef &#123; table=table1, oid=25 &#125;, right=BoundBaseTableRef &#123; table=table2, oid=26 &#125;, condition=(table1.x=table2.y) &#125;, <br>   columns=[table1.y, table2.x],                       <br>   groupBy=[],<br>   having=,  <br>   where=,  <br>   limit=, <br>   offset=,<br>   order_by=[],                                 <br>   is_distinct=false,         <br>   ctes=,<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，binder的作用就是对AST的各个节点绑定一个（物理）实体。</p><h3 id="planner"><a class="markdownIt-Anchor" href="#planner"></a> Planner</h3><p>得到 Bustub AST 后，Planner 遍历这棵树，生成初步的查询计划。查询计划也是一棵树的形式。例如这条 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> table1.y, table2.x <span class="hljs-keyword">FROM</span> table1 <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> table2 <span class="hljs-keyword">ON</span> t1.x <span class="hljs-operator">=</span> t2.y;<br></code></pre></td></tr></table></figure><p>查看 explain：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">=== PLANNER ===<br>Projection &#123; exprs=[#0.1, #0.2] &#125; | (table1.y:INTEGER, table2.x:INTEGER)                                                                                            <br>  NestedLoopJoin &#123; type=Inner, predicate=(#0.0=#1.1) &#125; | (table1.x:INTEGER, table1.y:INTEGER, table2.x:INTEGER, table2.y:INTEGER)                                   <br>    SeqScan &#123; table=table1 &#125; | (table1.x:INTEGER, table1.y:INTEGER)                                                                                                 <br>    SeqScan &#123; table=table2 &#125; | (table2.x:INTEGER, table2.y:INTEGER) <br></code></pre></td></tr></table></figure><p>上面的解释其实是树型的，如下图：<br /><img src="../img/busTub/query_excution/planner-tree.png" alt="" /><br />查询计划规定了数据的流向。数据从树叶流向树根，自底向上地流动，在根节点输出结果。</p><h3 id="optimizer"><a class="markdownIt-Anchor" href="#optimizer"></a> Optimizer</h3><p>生成查询计划后<br />由 Planner 得到初步的查询计划后，再将查询计划交给 Optimizer 进行修改优化，生成优化过后的最终查询计划。Optimizer 主要有两种实现方式：</p><ul><li>Rule-based.<ul><li>通过自动重写查询来避免效率低的方法。例如我们在 Task 3 中将要实现的，将 <code>Limit + Sort</code> 合并为 <code>TopN</code>。</li><li>这种 Optimizer 不需要知道数据的具体内容，仅是根据预先定义好的规则修改 <code>Plan Node</code>。</li></ul></li><li>Cost-based.<ul><li>用某种模型来预估执行计划的时间，这就需要存很多跟数据相关的数据</li><li>通过对不同模型的 cost 比较选出执行 cost 最小的。</li><li>这也会造成一些额外开销 （运行这个cost model）</li></ul></li></ul><p>Bustub 的 Optimizer 采用第一种实现方式。</p><blockquote><p>一般来说，Planner 生成的是 Logical Plan Node，代表抽象的 Plan。Optimizer 则生成 Physical Plan Node，代表具体执行的 Plan。例如是 Join。在 Planner 生成的查询计划中，Join 就是 Join。在 Optimizer 生成的查询计划中，Join 会被优化成具体的 HashJoin 或 NestedIndexJoin 等等。在 Bustub 中，并不区分 Logical Plan Node 和 Physical Plan Node。Planner 会直接生成 Physical Plan Node。</p></blockquote><h3 id="executor"><a class="markdownIt-Anchor" href="#executor"></a> Executor</h3><p>在拿到 Optimizer 生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子了。算子也是我们在 Project 3 中需要实现的主要内容。生成算子的步骤很简单，遍历查询计划树，将树上的 PlanNode 替换成对应的 Executor。算子的执行模型也大致分为三种：</p><ol><li><p>Iterator/Pipeline Model(volcano model)。每个算子都有 Init() 和 Next() 两个方法。Init() 对算子进行初始化工作。Next() 则是向下层算子请求下一条数据。当 Next() 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。火山模型一次调用只向下层算子请求一条数据，占用内存较小，但函数调用开销大。 <img src="../img/busTub/query_excution/iterator-model.png" alt="" /></p></li><li><p>Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高，但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。</p></li><li><p>Vectorized/Batch Model. 对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库采用这种模型。</p></li></ol><p>Bustub 采用 Iterator Model。</p><h2 id="metadata"><a class="markdownIt-Anchor" href="#metadata"></a> Metadata</h2><p>上面介绍了 sql语句执行过程，足以让我们对整个执行引擎有大体了解。但是我在做这个 lab 时候还是有很多困惑的地方。最后是迷迷糊糊的写完了才整理了下。大体上的信息包括在下图中：<br /><img src="../img/busTub/query_excution/table-matedata.png" alt="" /><br />（图片改自<a href="https://blog.eleven.wiki/posts/cmu15-445-project3-query-execution/">这篇博客</a>）</p><h2 id="task-1-access-method-executors"><a class="markdownIt-Anchor" href="#task-1-access-method-executors"></a> Task #1 - Access Method Executors</h2><h3 id="seqscan"><a class="markdownIt-Anchor" href="#seqscan"></a> SeqScan</h3><p>实现比较简单，获取 table_iter 直接遍历即可。这里说说这个<code>plan_-&gt;filter_predicate_</code>， 他是一个<code>AbstractExpressionRef</code>，而一个<code>AbstractExpression</code>意思是一个 <em>表达式</em> ，他里面最重要的两个函数是 <code>Evaluate(const Tuple *tuple, const Schema &amp;schema)</code>和 <code>EvaluateJoin(const Tuple *left_tuple, const Schema &amp;left_schema, const Tuple *right_tuple, const Schema &amp;right_schema)</code>，主要就是用来做 filter 的。例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> x <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果任何优化都没有，那么上述语句可以解析为两层：</p><ol><li>从 table1 中选出所有的 tuple。</li><li>选出 x = 1的 tuple。相当于底下的 seqscan 结点会将所有 tuple 发到上一层，然后上一层再做一次 filter。但是我们通过谓词下推，可以在seqscan 时候就通过 filter_predicate_ 将需要的过滤出来，不需要的不用发给上一层。（当然，这个例子不太准确。在这个情况下本来就是一次搞定的，总之是在复杂的时候可以把谓词下推）。<br />这个 Evaluate 返回一个 <code>Value</code>，实际上如果做filter应该返回 boolean，所以需要通过<code>filter_predicate_-&gt;Evaluate(tuple, table_info_-&gt;schema_).GetAs&lt;bool&gt;()</code>转化一下。<br />另外，seqscan 实际上不会用到 filter_predicate。后面遇到需要 predicate 的地方会再强调。</li></ol><h3 id="insert-delete"><a class="markdownIt-Anchor" href="#insert-delete"></a> Insert &amp; Delete</h3><p>这两个算子是唯二的写算子（实际上后面的优化过程中需要实现一个 update算子）。</p><p>我们先看下这两个算子的行为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">bustub<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> t1 <span class="hljs-keyword">values</span> (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;🥰&#x27;</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;🥰🥰&#x27;</span>, <span class="hljs-number">11</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;🥰🥰🥰&#x27;</span>, <span class="hljs-number">12</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;🥰🥰🥰🥰&#x27;</span>, <span class="hljs-number">13</span>), (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;🥰🥰🥰🥰&#x27;</span>, <span class="hljs-number">14</span>);<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span> output<br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> __bustub_internal.insert_rows <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">5</span>                             <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------------------------------+</span><br></code></pre></td></tr></table></figure><p>这两个算子他们会一直 next，然后返回一次，返回的是插入/删除 tuple 的个数（所生成的tuple）。有点像 <code>pipeline breaker</code>，但是由于他们一定是顶层算子，所以好像不叫 <code>pipeline breaker</code>。</p><p>个人感觉这个返回个数的设计有点不是很合理，它一定要将个数转化成一个tuple返回。大概是这样的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*tuple =<br>    <span class="hljs-built_in">Tuple</span>(std::<span class="hljs-built_in">vector</span>&lt;Value&gt;(<span class="hljs-built_in">GetOutputSchema</span>().<span class="hljs-built_in">GetColumnCount</span>() <span class="hljs-comment">/* ColumnCount() should be one*/</span>, <span class="hljs-built_in">Value</span>(TypeId::INTEGER, counter)),<br>          &amp;<span class="hljs-built_in">GetOutputSchema</span>());<br></code></pre></td></tr></table></figure><p>另外需要注意的就是这些 增加/删除 tuple 时，对应的索引项也需要增加/删除。</p><h3 id="indexscan"><a class="markdownIt-Anchor" href="#indexscan"></a> IndexScan</h3><p>这个就简单了，在 Init() 时候保存 index_iter， next() 时直接调用再自增就可以。</p><h2 id="task-2-aggregation-join-executors"><a class="markdownIt-Anchor" href="#task-2-aggregation-join-executors"></a> Task #2 - Aggregation &amp; Join Executors</h2><h3 id="aggregation"><a class="markdownIt-Anchor" href="#aggregation"></a> Aggregation</h3><p>aggregation 操作是一个 <code>pipeline breaker</code>。他会在 init 得到全部答案然后再 next 时一条一条返回。</p><p><code>SimpleAggregationHashTable</code> 维护一张哈希表，键为 <code>AggregateKey</code>，值为 <code>AggregateValue</code>，均为 <code>std::vector&lt;Value&gt;</code>。key 代表 group by 的字段的数组，value 则是需要 aggregate 的字段的数组。在下层算子传来一个 tuple 时，将 tuple 的 group by 字段和 aggregate 字段分别提取出来，调用 <code>InsertCombine()</code> 将 group by 和 aggregate 的映射关系存入 <code>SimpleAggregationHashTable</code>。若当前 hashmap 中没有 group by 的记录，则创建初值；若已有记录，则按 aggregate 规则逐一更新所有的 aggregate 字段，例如取 max/min，求 sum 等等。例如下面这条 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">min</span>(t.z), <span class="hljs-built_in">max</span>(t.z), <span class="hljs-built_in">sum</span>(t.z) <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> t.x, t.y;<br></code></pre></td></tr></table></figure><p>group by（AggregateKey）为 {t.x, t.y}，aggregate（AggregateValue）为 {t.z, t.z, t.z}。aggregate 规则为 {min, max, sum}。</p><p>需要额外注意 <code>count(column)</code> 和 <code>count(*)</code> 的区别，以及对空值的处理。</p><p>在 Init() 中计算出整张 hashmap 后，在 Next() 中直接利用 hashmap iterator 将结果依次取出。这里的输出形式有点奇怪，需要这样的输出：<br /><img src="../img/busTub/query_excution/aggregate-return.png" alt="" /></p><p><code>schema</code> 已经在 <code>GetOutputSchema()</code> 中准备好了。</p><h3 id="nestedloopjoin"><a class="markdownIt-Anchor" href="#nestedloopjoin"></a> NestedLoopJoin</h3><p>我的实现比较 tricky。我在 init 时候直接把下层算子（left_executor和right_executor）所有的tuple都得到了（相当于当作 pipeline breaker），保存在两张表中。再 next时候进行匹配。这里的 left-join 和 inner-join 是需要分开实现的，可以在网上查下left-join和inner-join的区别。<br />在这里判断左右两个 tuple 是否 match 就需要用到<code>plan_-&gt;Predicate().EvaluateJoin()</code>，同样要 <code>GetAs&lt;bool&gt;()</code>。</p><p>当我们得到一个 match 后，返回前记得<strong>保存上下文</strong>，例如，你可以保存 match 的 tuple 再左表中的下标和右表中的下标，这样下次调用 next 时候，就不用重新扫描一次。</p><h3 id="nestedindexjoin"><a class="markdownIt-Anchor" href="#nestedindexjoin"></a> NestedIndexJoin</h3><p>在进行 equi-join 时，如果发现 JOIN ON 右边的字段上建了 index，则 Optimizer 会将 NestedLoopJoin 优化为 NestedIndexJoin。具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p><h2 id="task-3-sort-limit-executors-and-top-n-optimization"><a class="markdownIt-Anchor" href="#task-3-sort-limit-executors-and-top-n-optimization"></a> Task #3 - Sort + Limit Executors and Top-N Optimization</h2><h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h3><p>这个实验的 sort 无需进行外部排序，重载小于后就可以实现。就是比较的方式有点奇怪，可以类比以下写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">order_key.second-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;lhs, schema).<span class="hljs-built_in">CompareLessThan</span>(order_key.second-&gt;<span class="hljs-built_in">Evaluate</span>(&amp;rhs, schema))<br></code></pre></td></tr></table></figure><h3 id="limit"><a class="markdownIt-Anchor" href="#limit"></a> limit</h3><p>简单，limit 限制在 <code>plan_-&gt;Getlimit()</code>里面。</p><h3 id="top-n-optimization-rule"><a class="markdownIt-Anchor" href="#top-n-optimization-rule"></a> Top-N Optimization Rule</h3><p>简单，优先队列重载小于（重载方式与 sort 相同），然后截取前 n 个。</p><h3 id="sort-limit-as-topn"><a class="markdownIt-Anchor" href="#sort-limit-as-topn"></a> Sort + Limit As TopN</h3><p>这是 Project 3 里最后一个必做的小问，也是唯一一个 Optimizer ，将 Sort + Limit 优化为 TopN。先看看 Optimizer 是如何执行优化规则的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Optimizer::OptimizeCustom</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;<br>  <span class="hljs-keyword">auto</span> p = plan;<br>  p = <span class="hljs-built_in">OptimizeMergeProjection</span>(p);<br>  p = <span class="hljs-built_in">OptimizeMergeFilterNLJ</span>(p);<br>  p = <span class="hljs-built_in">OptimizeNLJAsIndexJoin</span>(p);<br>  p = <span class="hljs-built_in">OptimizeNLJAsHashJoin</span>(p);  <span class="hljs-comment">// Enable this rule after you have implemented hash join.</span><br>  p = <span class="hljs-built_in">OptimizeOrderByAsIndexScan</span>(p);<br>  p = <span class="hljs-built_in">OptimizeSortLimitAsTopN</span>(p);  <span class="hljs-comment">// what we should add</span><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，让未经优化的原始 plan 树依次经历多条规则，来生成优化过的 plan。我们的任务就是新增一条规则。看看其他规则是怎么实现的，例如 NLJAsIndexJoin：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Optimizer::OptimizeNLJAsIndexJoin</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef </span>&#123;<br>  std::vector&lt;AbstractPlanNodeRef&gt; children;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;child : plan-&gt;<span class="hljs-built_in">GetChildren</span>()) &#123;<br>    children.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">OptimizeNLJAsIndexJoin</span>(child));<br>  &#125;<br>  <span class="hljs-keyword">auto</span> optimized_plan = plan-&gt;<span class="hljs-built_in">CloneWithChildren</span>(std::<span class="hljs-built_in">move</span>(children));<br><br>  <span class="hljs-keyword">if</span> (optimized_plan-&gt;<span class="hljs-built_in">GetType</span>() == PlanType::NestedLoopJoin) &#123;<br>    <span class="hljs-comment">// apply the rule and return</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> optimized_plan;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，实际上就是对 plan tree 进行后序遍历，自底向上地适用规则，改写节点。遍历到某个节点时，通过 if 语句来判断当前节点的类型是否符合我们要优化的类型，若符合则进行优化。</p><p>大致了解如何对 plan 进行优化后，就可以开始写我们的优化规则了。需要特别注意的是，能优化为一个 TopN 算子的形式是，上层节点为 Limit，下层节点为 Sort，不能反过来。同样，我们对 plan tree 进行后续遍历，在遇到 Limit 时，判断其下层节点是否为 Sort，若为 Sort，则将这两个节点替换为一个 TopN。还是比较好实现的，只是代码看起来可能有点复杂。</p><h2 id="leaderboard-task"><a class="markdownIt-Anchor" href="#leaderboard-task"></a> Leaderboard Task</h2><p>暂时还没写，有空了补补</p><p><strong>AC!</strong><br /><img src="../img/busTub/query_excution/p3-result.png" alt="" /></p><h2 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h2><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2022/bustub/">bustub on web</a></li><li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li><li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li><li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>cmu15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛中的Wavelet Tree</title>
    <link href="/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84Wavelet-Tree/"/>
    <url>/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84Wavelet-Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="wavelet-tree-for-competitive-programming"><a class="markdownIt-Anchor" href="#wavelet-tree-for-competitive-programming"></a> Wavelet Tree for Competitive Programming</h1><blockquote><p>最近在学<em>FM-Index</em>相关算法用于数据库，了解到Wavelet Tree这一数据结构，发现其还可以应用在算法竞赛中。网上相关中文资料比较少，权当自己做个学习笔记</p></blockquote><h2 id="开始之前"><a class="markdownIt-Anchor" href="#开始之前"></a> 开始之前</h2><p>在学习<code>wavelet tree</code>前，不妨看看他能解决什么样的问题。</p><p>假设我们有一长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mn>0...</mn><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[0...n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 。在算法竞赛中，典型的数据量是  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>1</mn><mi>e</mi><mn>5</mn><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo>=</mo><mn>1</mn><mi>e</mi><mn>9</mn></mrow><annotation encoding="application/x-tex">n = 1e5,  |A[i]| &lt;= 1e9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">9</span></span></span></span></p><ul><li>区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[L, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 中元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>的<code>出现次数</code></li><li>区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[L, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 中的<code>第k小数</code></li><li>区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[L, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span> 上 <code>小于等于x的数的个数</code></li><li>…</li></ul><p>以上问题都可以通过<em>可持久化线段树</em>在解决。那为什么还需要wavelet tree呢，我们都知道可持久化线段树的常数很大，并且十分消耗空间，在有些苛刻的题目下可能会被卡  <s>好吧应该都是金牌题，不是我该考虑的</s> 。利用wavelet tree可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(\sigma)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">)</span></span></span></span>时间内完成的同时（且优秀的常数），若使用<code>bitvector</code>优化空间，空间上大概比可持久化线段树少一个量级。最重要的一点是，我个人觉得他比主席树更加直观易懂。<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> = | <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma = \{1, 2, \cdots, \sigma\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mclose">}</span></span></span></span>| （用于序列上时是值域大小）。</p><blockquote><p>用wavelet tree的缺点就是带修改操作比较难写，码量较大，一般不会在比赛时使用。</p></blockquote><h2 id="wavelet-tree"><a class="markdownIt-Anchor" href="#wavelet-tree"></a> Wavelet Tree</h2><p><img src="../img/waveletTree/waveletTree.png" alt="" /></p><p>该图给出了用序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">[</mo><mn>7</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A = [7, 3, 5, 6, 1, 3, 2, 7, 8, 4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 构建的wavelet tree的形态。对于树上的每个节点，我们会将其按照值域分成两个部分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[low, mid), [mid, high)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>。通过 <strong>稳定划分</strong>（stable_partition，即不改变相对顺序的情况下划分）将该节点上的序列中小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>的划分到左子树中，大于等于mid的划分到右子树中，递归直至节点中只有一种值时为叶节点。需要注意的是，我们并不会在叶子节点中直接存储序列的值，而是通过某个方法使得我们能够使用较小的空间的情况下得到足够的信息。</p><p>设根节点编号为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">u = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，其左子树的根节点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>u</mi></mrow><annotation encoding="application/x-tex">2 * u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> , 右子树的根节点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mi>u</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 * u + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，以此类推。每个节点都对应一对左闭右开的区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[lo, hi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>，表示该节点中数值的值域范围。同时有一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>l</mi><mi>o</mi><mo>+</mo><mi>h</mi><mi>i</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">mid = \lfloor \frac{lo + hi}{2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span> ，表示该节点左右子树分裂标准，即左子树中值域范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mo separator="true">,</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[lo, mid)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span> , 右子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>h</mi><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[mid, hi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span> 。</p><p>在wavelet tree中，我们实际上在维护一个二维数组<code>vector&lt;vector&lt;int&gt;&gt; c</code>，我们不妨叫他<strong>前缀计数数组</strong>，其中 <strong><code>c[u][i]</code>表示的是u结点中下标为[0, i)中的数有多少个小于该节点对应的mid</strong>。另外，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>结点中有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>个数，那么<code>c[u].size() = n + 1</code>， 我们另<code>c[u][0] = 0</code>。例如，下图给出了部分结点对应的 <code>c[u][i]</code>数组<br /><img src="../img/waveletTree/Counting-array.png" alt="" /></p><p>现在，我们来看如何用这个构建好的前缀计数数组完成以下的查询问题：</p><h3 id="rankint-val-int-pos"><a class="markdownIt-Anchor" href="#rankint-val-int-pos"></a> rank(int val, int pos)</h3><p>该函数返回区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 中值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的数的个数（我也不知道为什么叫rank。。。或许这个名称是由bitvector中继承而来？）。有了这个函数，我们就容易得到区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[i, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 内某个数的出现次数，就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank(val, j) - rank(val, i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></p><p>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mi>u</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_u (val, pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 为结点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>中值为val的数在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0, pos)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 中的出现次数（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mo>&lt;</mo><mo>=</mo><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pos &lt;= size(u)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span> ）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>为节点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>分裂标准，我们可以得到：</p><ul><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>&lt;</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">val &lt; mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mi>u</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mrow><mi>L</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_u(val, pos) = rank_{LeftChild(u)}(val, c[u][pos])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">L</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li><li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>&gt;</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">val &gt;= mid</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span></span></span></span>,  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mi>u</mi></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mrow><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>C</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mi>u</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_u(val, pos) = rank_{RightChild(u)}(val, pos - c[u][pos])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">u</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">u</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></li></ul><p>如何理解上述变化呢，其实也很简单，就是要理解<code>c[u][i]</code>的意义，它同时也表示将u结点中下标为i的点映射到子结点中后他的位置。而映射规则为<strong>若这个数小于mid，则将其映射到左儿子的c[u][i]处；若这个数大于等于mid，则将其映射到右儿子的i-c[u][i]处</strong> 不理解的可再仔细想想<code>c[u][i]</code>的这两个解释之间的等价性。</p><p>有了上述说明，我们就容易递归的完成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">rank</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>操作。例如，假设我们需要得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo>=</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_1(val = 3, pos = 7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span><br />-由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>&lt;</mo><mi>m</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">，</mi><mi>c</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>7</mn><mo stretchy="false">]</mo><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">3&lt;mid，c[1][7] = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">7</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>, 则递归左子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_2(3, 4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span>；</p><ul><li>左子树中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>&gt;</mo><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>4</mn><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 &gt;= (mid = 2), 4-c[2][4] = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，递归到右子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><msub><mi>k</mi><mn>5</mn></msub><mo stretchy="false">(</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rank_5(3, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></li><li>右子树中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>&gt;</mo><mo>=</mo><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>3</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>3</mn><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3 &gt;= (mid = 3), 3-c[5][3] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，递归到右子树</li><li>右子树为叶子节点，则此时结点内的树的个数（即为上一步中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mo>−</mo><mi>c</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3-c[5][3] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>）为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的个数</li></ul><h3 id="quantileint-k-int-l-int-r"><a class="markdownIt-Anchor" href="#quantileint-k-int-l-int-r"></a> quantile(int k, int l, int r)</h3><p>该函数返回区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[l, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>间的第k小数（最小的为第一小）。我们知道，<code>c[u][l]</code>表示下标为结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>中有多少个下标在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mi mathvariant="normal">，</mi><mi>l</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[0， l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span></span></span></span>中的数被映射到了左子树。那么，</p><ul><li>若<code>c[u][r] - c[u][l] &gt;= k</code>，则区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[l, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>内第k小即为左子树中的第k小。</li><li>若<code>c[u][r] - c[u][l] &lt; k</code>，则区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[l, r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>内第k小即为右子树中的第<code>k - (c[u][r] - c[u][l])</code>小。</li></ul><p>从而我们可以递归的进行求解。</p><h3 id="c数组的构建"><a class="markdownIt-Anchor" href="#c数组的构建"></a> c数组的构建</h3><p>实际上上面已经讲的差不多了，直接看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 参数都是该结点对应序列相关</span><br><span class="hljs-comment">// u: 该结点编号</span><br><span class="hljs-comment">// begin， end: 该结点对应序列的首个，末尾迭代器</span><br><span class="hljs-comment">// lo, hi： 该结点对应值域为 [lo, hi)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(iter begin, iter end, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(hi - lo == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>    c[u].<span class="hljs-built_in">reserve</span>(end - begin + <span class="hljs-number">1</span>); <span class="hljs-comment">// reverse只分配空间不进行构造，所以后面还可以push_back</span><br>    c[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin; it != end; ++it) &#123;<br>        c[u].<span class="hljs-built_in">push_back</span>(c[u].<span class="hljs-built_in">back</span>() + (*it &lt; m));<br>    &#125;<br><br>    <span class="hljs-comment">// 稳定划分，将[begin, end)间的小于m的值划分到前半部分，pivot为后半部分首个迭代器</span><br>    <span class="hljs-keyword">auto</span> pivot = <span class="hljs-built_in">stable_partition</span>(begin, end, [=](<span class="hljs-type">int</span> i)&#123;<span class="hljs-keyword">return</span> i &lt; m&#125;;);<br><br>    <span class="hljs-built_in">build</span>(begin, pivot, lo, m, <span class="hljs-number">2</span> * u);<br>    <span class="hljs-built_in">build</span>(pivot, end, m, hi, <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>到这个，我们已经可以利用没有进行空间优化的wavelet tree轻松切掉这道 <a href="https://www.luogu.com.cn/problem/P3834">可持久化线段树的模板题</a>了，代码如下</p><h2 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WaveletTree</span> &#123;<br>    <span class="hljs-keyword">using</span> iter = vector&lt;<span class="hljs-type">int</span>&gt;::iterator;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; c;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> SIGMA;<br><br>    <span class="hljs-built_in">WaveletTree</span>(vector&lt;<span class="hljs-type">int</span>&gt; a, <span class="hljs-type">int</span> sigma): <span class="hljs-built_in">c</span>(sigma*<span class="hljs-number">2</span>), <span class="hljs-built_in">SIGMA</span>(sigma) &#123;<br>        <span class="hljs-built_in">build</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>, SIGMA, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(iter begin, iter end, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(hi - lo == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>        c[u].<span class="hljs-built_in">reserve</span>(end - begin + <span class="hljs-number">1</span>);<br>        c[u].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = begin; it != end; ++it) &#123;<br>            c[u].<span class="hljs-built_in">push_back</span>(c[u].<span class="hljs-built_in">back</span>() + (*it &lt; m));<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">stable_partition</span>(begin, end, [=](<span class="hljs-type">int</span> i)<br>                                  &#123; <span class="hljs-keyword">return</span> i &lt; m; &#125;);<br>        <span class="hljs-built_in">build</span>(begin, p, lo, m, <span class="hljs-number">2</span> * u);<br>        <span class="hljs-built_in">build</span>(p, end, m, hi, <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// occurrences of val in position[0, i)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rank</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> i)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(val &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> val &gt;= SIGMA) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> lo = <span class="hljs-number">0</span>, hi = SIGMA, u = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hi - lo &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(val &lt; m) &#123;<br>                i = c[u][i], hi = m;<br>                u = u * <span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                i -= c[u][i], lo = m;<br>                u = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-comment">// get kth smallest number in [l, r)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quantile</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// assert(k &gt; 0 &amp;&amp; k &lt;= j - i);</span><br>        <span class="hljs-type">int</span> lo = <span class="hljs-number">0</span>, hi = SIGMA, u = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(hi - lo &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> m = (lo + hi) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> nl = c[u][l], nr = c[u][r];<br>            <span class="hljs-keyword">if</span>(k &lt;= nr - nl) &#123;<br>                r = nr, l = nl, hi = m;<br>                u = <span class="hljs-number">2</span> * u;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                k -= nr - nl;<br>                r -= nr, l -= nl, lo = m;<br>                u = <span class="hljs-number">2</span> * u + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lo;   <br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">int</span> n, q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;x : a) &#123;<br>        cin &gt;&gt; x;<br>    &#125;<br>    <span class="hljs-function">WaveletTree <span class="hljs-title">wt</span><span class="hljs-params">(a, *max_element(a.begin(), a.end()) + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">while</span>(q --) &#123;<br>        <span class="hljs-type">int</span> k, l, r;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;<br>        l--;<br>        cout &lt;&lt; wt.<span class="hljs-built_in">quantile</span>(k, l, r) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>icpc</tag>
      
      <tag>data-structure</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-project2 Concurrent B+ tree</title>
    <link href="/CMU15445-project2-Concurrent-B-tree/"/>
    <url>/CMU15445-project2-Concurrent-B-tree/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><blockquote><p>这个实验应该是最难的一个实验了。。。（感觉和Project 4 —— Transaction实现的难度差不多） 另外，2022fall版本的B+ tree更是变态，因为几乎没有给任何内部的API，让人无从下手。建议到 Github repo 里找到20年的，我基本是根据里面定义的函数来实现的。</p></blockquote><p>实验材料<s>贴心的</s>为你分成了两个检查点，四个小任务。</p><p>Checkpoint #1</p><ul><li>Task #1 - B+Tree Pages</li><li>Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)</li></ul><p>Checkpoint #2</p><ul><li>Task #3 - Index Iterator</li><li>Task #4 - Concurrent Index</li></ul><h2 id="task-1-btree-pages"><a class="markdownIt-Anchor" href="#task-1-btree-pages"></a> Task #1 - B+Tree Pages</h2><p>第一个任务算是热身，主要是搞清楚 B+ 树的一些类之间的关系。<br />我们知道，数据库中的索引也是数据，同样以 page 的形式被组织。我们先来看看要完成的这些类之间的关系。</p><p><img src="../img/busTub/B-tree/B-tree-page-relation.png" alt="" /></p><p><code>B+ tree internal page</code> 与 <code>B + tree leaf page</code> 都继承自<code>B + tree page</code>，<code>B + tree page</code> 中定义了 B+ 树每个结点的一些信息。而B + Tree 这个类则是Checkpoint 1的主要对象，它对<code>internal page</code> 以及 <code>leaf page</code> 进行管理，并对外开放接口。而在内存中，internal page 与 leaf page 都属于 page 的一部分，关系如下图所示。他们就是 <code>page</code> 中的 data 部分。因此，每次<br />从 buffer pool manager 得到一个 page 后，若是将他们用作 B+树的结点，则需要对这个 data 进行<strong>释义</strong>，也就是将他强制转化为internal page 或者 leaf page。这在 C++ 中通过 <a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast"><strong>reinterpret_cast</strong></a> 完成。</p><p><img src="../img/busTub/B-tree/pages.png" alt="" /></p><p>然后就是一些getter，setter的实现。这个 <code>MappingType array[1]</code> 是个奇技淫巧叫<a href="https://en.wikipedia.org/wiki/Flexible_array_member">flexible array member</a>，由于整个internal page的大小是确定的（由data[buffer_size]转义而来），这个 array 的大小就是去掉 header后的大小。（另外，实际上应该写作 <code>MappingType array[0]</code>，不然过不了 check-format）。</p><h2 id="task-2-btree-data-structure-insertion-deletion-point-search"><a class="markdownIt-Anchor" href="#task-2-btree-data-structure-insertion-deletion-point-search"></a> Task #2 - B+Tree Data Structure (Insertion, Deletion, Point Search)</h2><p>这个任务就是本实验最为核心的一点——实现基于磁盘的 B+ 树数据结构。这里不会详细展开，因为过于复杂且很多细节<s>因为忘光了</s>。给个<a href="https://github.com/cmu-db/bustub/blob/1cc1bb2f7b0746c67a974c0554c843ac35519315/src/storage/index/b_plus_tree.cpp">20年fall</a>的B+ tree，功能是一样的，但是提供了完善的内部接口，照着这个和书上完成要清晰不少。</p><h3 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> debug</h3><p>TAs准备了b_plus_tree_printer工具，并且已经准备的Draw/ToString方法，善用它们将B+树可视化，更好的观察插入、删除行为是否正确。 示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;     <br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> key : keys) &#123;       <br>  <span class="hljs-type">int64_t</span> value = key &amp; <span class="hljs-number">0xFFFFFFFF</span>;       <br>  rid.<span class="hljs-built_in">Set</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int32_t</span>&gt;(key &gt;&gt; <span class="hljs-number">32</span>), value);       <br>  index_key.<span class="hljs-built_in">SetFromInteger</span>(key);       <br>  tree.<span class="hljs-built_in">Insert</span>(index_key, rid, transaction);       <br>  tree.<span class="hljs-built_in">Draw</span>(bpm, <span class="hljs-string">&quot;xxxxx/InsertTest_step&quot;</span> + std::<span class="hljs-built_in">to_string</span>(step++) + <span class="hljs-string">&quot;_insert&quot;</span> + std::<span class="hljs-built_in">to_string</span>(key) + <span class="hljs-string">&quot;.dot&quot;</span>);     <br>&#125;     <br>tree.<span class="hljs-built_in">Draw</span>(bpm, <span class="hljs-string">&quot;xxxxxx/InsertTest_step.dot&quot;</span>);<br></code></pre></td></tr></table></figure><p>得到生成的文件后打开，可以和<a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">reference solution</a>比较。</p><h2 id="task-3-index-iterator"><a class="markdownIt-Anchor" href="#task-3-index-iterator"></a> Task #3 - Index Iterator</h2><p>我想重点说下这个 iterator 的实现，因为在这个实验中，我调了最久的 bug 就出现在这个子任务中。（实际上已经过了lab-2的评测已经过了，是在 lab3评测时发生锁资源的问题）</p><p>记得哪个大佬说过，如何看一个人的 C++ 水平，从他写的构造函数就可以略窥一二。C++ 的构造函数属实花里胡哨，<code>copy ctor</code>, <code>copy assignment</code>, <code>move ctor</code>, <code>move assignment</code> , 再加上 <code>initializatier list</code>以及模板… 哪些要写，哪些应当禁止都是门学问。</p><p>根据 <a href="https://zh.wikipedia.org/zh-hans/RAII">RAII</a> 的思想，C++ 的 contructor（配合dtor）肩负了管理资源的作用。这个资源不知包括内存资源，还包括锁资源等等。而对于 Index iterator 来说，每个 iterator 都带有一个隐含的读属性，并发读要求对 page 上读锁，但是我们的 iterator 又不直接管理 page 资源，需要通过传入指针（用shared_ptr最好）的方式对 page 进行操作。</p><p>我们来看这个例子 在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">index_iter_ = <span class="hljs-built_in">GetBPlusTreeIndex</span>()-&gt;<span class="hljs-built_in">GetBeginIterator</span>();<br></code></pre></td></tr></table></figure><p>这是lab3中用到索引迭代器的一个地方的代码。注意到这会产生一个临时对象，并把它赋值给 index_iter_。如果我们在析构的时候释放了对应 page 的锁而没有写<code>copy assignment</code>，编译器生成的assignment是不会在赋值的时候为page上锁的。</p><p>这个bug归根结底在于，我们的迭代器应该是 <strong>值语义(value semantic)</strong> 的（至少对于锁资源来讲）</p><p>我们用 <strong>copy and swap</strong> idiom 来解决这个问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-title">INDEXITERATOR_TYPE::IndexIterator</span><span class="hljs-params">(BufferPoolManager *bpm, Page *page, <span class="hljs-type">int</span> index, <span class="hljs-type">page_id_t</span> page_id)</span></span><br><span class="hljs-function">    : bpm_(bpm), page_(page), index_(index), page_id_(page_id) &#123;</span><br>  <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>    leaf_ = <span class="hljs-built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(page-&gt;<span class="hljs-built_in">GetData</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    leaf_ = <span class="hljs-literal">nullptr</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="hljs-function"><span class="hljs-title">INDEXITERATOR_TYPE::IndexIterator</span><span class="hljs-params">(<span class="hljs-type">const</span> IndexIterator &amp;rhs)</span></span><br><span class="hljs-function">    : bpm_(rhs.bpm_), index_(rhs.index_), page_id_(rhs.page_id_), leaf_(rhs.leaf_) &#123;</span><br>  <span class="hljs-keyword">if</span> (page_id_ != INVALID_PAGE_ID) &#123;<br>    page_ = bpm_-&gt;<span class="hljs-built_in">FetchPage</span>(page_id_);<br>    page_-&gt;<span class="hljs-built_in">RLatch</span>();<br>  &#125;<br>&#125;<br><br>INDEX_TEMPLATE_ARGUMENTS<br><span class="hljs-keyword">auto</span> INDEXITERATOR_TYPE::<span class="hljs-keyword">operator</span>=(IndexIterator rhs) -&gt; IndexIterator &amp; &#123;<br>  <span class="hljs-built_in">Swap</span>(*<span class="hljs-keyword">this</span>, rhs);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Swap</span><span class="hljs-params">(IndexIterator &amp;lhs, IndexIterator &amp;rhs)</span> </span>&#123;<br>  <span class="hljs-keyword">using</span> std::swap;<br>  <span class="hljs-built_in">swap</span>(lhs.bpm_, rhs.bpm_);<br>  <span class="hljs-built_in">swap</span>(lhs.page_, rhs.page_);<br>  <span class="hljs-built_in">swap</span>(lhs.index_, rhs.index_);<br>  <span class="hljs-built_in">swap</span>(lhs.page_id_, rhs.page_id_);<br>  <span class="hljs-built_in">swap</span>(lhs.leaf_, rhs.leaf_);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="task-4-index-iterator"><a class="markdownIt-Anchor" href="#task-4-index-iterator"></a> Task #4 - Index Iterator</h2><p>这是并发 B+ 树的重点。我们要使此前实现的 B+ 树支持并发的 Search/Insert/Delete 操作。整棵树一把锁逻辑上来说当然是可以的，但性能肯定不行，我们需要更加细粒度的锁管理。在这里，我们会使用一种特殊的加锁方式，叫做 latch crabbing。顾名思义，就像螃蟹一样，移动一只脚，放下，移动另一只脚，再放下。基本思想是：</p><ol><li>先锁住 parent page，</li><li>再锁住 child page，</li><li>假设 child page 是安全的，则释放 parent page 的锁。安全指当前 page 在当前操作下一定不会发生 split/steal/merge。同时，安全对不同操作的定义是不同的，Search 时，任何节点都安全；Insert 时，判断 max size；Delete 时，判断 min size。</li></ol><p>这么做的原因和正确性还是比较明显的。当 page 为安全的时候，当前操作仅可能改变此 page 及其 child page 的值，因此可以提前释放掉其祖先的锁来提高并发性能。</p><p>最后是AC截图：</p><p><img src="../img/busTub/B-tree/p2-result.png" alt="" /></p><h2 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h2><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li><li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li><li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>cmu15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-project1 Buffer Pool Manager</title>
    <link href="/CMU15445-project1-Buffer-Pool-Manager/"/>
    <url>/CMU15445-project1-Buffer-Pool-Manager/</url>
    
    <content type="html"><![CDATA[<h1 id="buffer-pool-manager"><a class="markdownIt-Anchor" href="#buffer-pool-manager"></a> Buffer Pool Manager</h1><blockquote><p>cmu15445 是一门关于数据库管理系统（DBMS）设计与实现的经典公开课，是很多dba和内核开发人员的入门课程。开课教授Andy Pavlo 非常风趣幽默，他有自己上课的DJ，他曾在浴缸里录课，且时常语出惊人。这门课的实验项目BusTub非常有挑战性，并对所有人开放评测资源。</p></blockquote><h2 id="overview"><a class="markdownIt-Anchor" href="#overview"></a> Overview</h2><p>BusTub是一个面向磁盘的 DBMS(Database Management System)。由于磁盘上的数据不支持字节粒度的访问，这就需要一个管理页的中间层，而 Andy 坚持<a href="https://db.cs.cmu.edu/mmap-cidr2022/">&quot;The OS is not your friend&quot;</a>， 反对使用 mmap 进行页操作，因此实验一的目标便在于通过实现 Buffer Pool Manager 主动管理磁盘中的页（page）在内存中的缓存，从而，最小化磁盘访问次数（时间上）、最大化相关数据连续（空间上）。</p><p>这次实验有三个子任务，分别是</p><ul><li>Task #1: Extendible Hash Table</li><li>Task #2: LRU-K Replacer</li><li>Task #3: Buffer Pool Manager Instance</li></ul><p>可拓展哈希表是这个是实验中相对独立的模块。这里不会讲它的细节，后面的两个任务中需要用到哈希表的地方我直接用std::unordered_map替代，而且效率还更高。应该是因为 Extendible Hash Table 要求线程安全，为了方便在我在每个函数入口都加了大锁。<br />想要 Extendible Hash Table 具体细节的可以看这个<a href="https://www.bilibili.com/video/BV1nV4y1N7LM/?spm_id_from=333.788&amp;vd_source=11c680307875dda5d5b5c13fca2e5c57">b站视频</a>。关于它的优化，我想可以进行更细粒度的锁管理甚至写一个无锁(lockfree)的哈希表。</p><h2 id="buffer-pool-manager-2"><a class="markdownIt-Anchor" href="#buffer-pool-manager-2"></a> Buffer Pool Manager</h2><p>在后两个实验开始之前，我建议先将Task #2和Task #3的<a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">实验材料</a>完整的看完在开始写代码。因为 <code>replacer</code> 和 <code>buffer pool manager</code> 有较大程度的耦合。很多API设计需要对照两个组件才能知道自己应该维护的数据与功能的边界。为了更符合直觉，我会先阐述 <code>buffer pool manager</code> 的设计，同时会穿插着 <code>LRU-k</code> 的API什么时候，在哪用。</p><p><strong>Buffer Pool Manager</strong> 维护的数据的基本单位为一段逻辑连续的字节数组，在磁盘上表现为<strong>页（page）</strong>，页内部结构有自己的一些结构（包括header, content等），在这个实验中我们只关心 <code>page_id_</code> (页的唯一标识)， <code>pin_conut_</code> 以及 <code>is_dirty_</code> 。对应在内存上，我们用 <strong>frame</strong> 这个词代表 <strong>框</strong>，就是装着某个物理页的框。在代码中其实就是buffer pool管理着一大片内存 <code>Page pages[pool_size_]</code>，但是 buffer pool 初始化时（资源获取时）我们得到的 pages 并不包含我们想要的页，它里面的数据是没有意义的，从而它是一个<em>空的框</em>。frame_id指的就是这个数组的下标。里面装的页有自己的<code>page_id</code>。另外，我们用一个哈希表<code>page_table_</code>保存从 页号(page id) 到 框号(frame_id) 的映射。</p><img src="../img/busTub/buffer_pool_manager/pages.png" width="75%" height="75%"><p>管理帧的内存池大小一般来说是远小于磁盘的，因此在内存池满了后，再从磁盘加载新的页到内存池，需要某种替换策略（replacer）将一些不再使用的页踢出内存池以腾出空间。</p><p>buffer pool manager 的<strong>实现核心</strong>在于对所有 page 的状态的管理。每个page有四种状态：</p><ol><li><strong>Not Allocated(Not Exist):</strong> 我们将不存在的 page 也当作一种状态</li><li><strong>Allocated but Not in MEM:</strong> allocated 但是不存在于内存中（某一时刻内存装的 page 达到上线后被 evict 出内存）</li><li><strong>Unpinned and in MEM:</strong> 随时可能被 evict</li><li><strong>Pinned(definitely in MEM)</strong></li></ol><p><strong>这几种状态是互斥的</strong></p><p>待实现函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::NewPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> *page_id)</span> -&gt; Page *</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> -&gt; Page *</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">bool</span> is_dirty)</span> -&gt; <span class="hljs-type">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::DeletePgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> -&gt; <span class="hljs-type">bool</span></span><br></code></pre></td></tr></table></figure><p>便是驱动状态机中上述状态发生改变的动作（action），（注意： <em>AllocatePage 和 DeallocatePage</em>不对外部公开） 状态机如下：</p><img src="../img/busTub/buffer_pool_manager/state-machine-of-page.png" width="50%" height="50%"><p>每个函数声明处的注释已经非常详细的描述了函数行为了。以下列出一些我在做的时候容易困惑的点：</p><ul><li><code>page_table_</code>维护的只是在内存中的page的<code>page_id</code>到<code>frame_id</code>的映射。也就是说它不保存 <em>Allocated but not in MEM</em> 的 page（因为在磁盘上的page也没有一个到 <code>frame_id</code> 的映射）</li><li><code>Unpin</code> 操作并不一定会使 page 变成 <em>Unpinned and in MEM</em>，因为这只是这一个 <em>worker（一般来说是一个thread）</em> 对该 page 进行 unpin，其他线程可能也正在读取这个 page 的内容。 只有当 某次 Unpin 操作后，它的<code>pin_count_</code> 等于0时，才能让这个 page 变成 <code>evitable</code>的状态（在 replacer 中维护）</li><li><code>AllocatePage</code> 只在 <code>NewPage</code>中用到，<code>DeallocatePage</code> 只在 <code>DeletePage</code> 中用到</li><li><code>Unpin</code> 的 <code>is_dirty</code> 参数为 true 时，将这个 page 的<code>is_dirty_</code>设置为true， <strong>而当参数为false时，不可以将page的 is_dirty_ 设置为false! 而应该保持原 dirty 状态不变</strong> 因为 <code>is_dirty</code> 参数表示的只是这个线程是否对这个 page 有修改操作。（这个点害我debug了好久）</li></ul><p>现在我们借助 replacer 的 API 来理解一下每个 page 在他的生命周期中需要被维护什么内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发生在NewPage和FetchPage时，且free_list_为空</span><br><span class="hljs-comment"> * @param[out] frame_id id of frame that is evicted.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Evict</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> *frame_id)</span> -&gt; <span class="hljs-type">bool</span></span>;<br><br><span class="hljs-comment">/* 发生在NewPage和FetchPage中 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecordAccess</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span></span>;<br><br><span class="hljs-comment">/** 在NewPage和FetchPage set_evictable 设置为 false</span><br><span class="hljs-comment"> *  在 Unpin后，pin_count为0下 set_evictable 设置为 true</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetEvictable</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id, <span class="hljs-type">bool</span> set_evictable)</span></span>;<br><br><span class="hljs-comment">/* 发生在DeletePage中 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Remove</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span></span>;<br></code></pre></td></tr></table></figure><p>以 FetchPageImpl 为例强调下一些实现的细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> -&gt; Page * </span>&#123;<br>  <span class="hljs-comment">// 1. 上锁！</span><br>  <span class="hljs-comment">// 2. 查看 page 是否在 page_table_ 中</span><br>  <span class="hljs-comment">//  2.1 若在 </span><br>  <span class="hljs-comment">//   2.1.2 得到frame_id, 目标为pages[frame_id]</span><br>  <span class="hljs-comment">//   2.1.3 目标内部的pin_count状态维护</span><br>  <span class="hljs-comment">//   2.1.4 replacer 维护recordAccess和setEvictable</span><br>  <span class="hljs-comment">//   2.1.5 返回</span><br>  <span class="hljs-comment">// 2.2 若不在</span><br>  <span class="hljs-comment">//  2.2.1 找一个可用的 frame (先从free list里找，没有则让 replacer evict一个)</span><br>  <span class="hljs-comment">//  2.2.2 清空frame_id中原来的信息 （包括old_page dirty的话写回磁盘）</span><br>  <span class="hljs-comment">//  2.2.3 维护 page_table (删除这个frame_id对应的old_page的信息)</span><br>  <span class="hljs-comment">//  2.2.4 设置新的page_id，从磁盘中读入，并维护新 page 内部信息</span><br>  <span class="hljs-comment">//  2.2.5 维护 replacer 相关</span><br>  <span class="hljs-comment">//  2.2.6 维护page_table </span><br>  <span class="hljs-comment">//  2.2.7 返回</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="lru-k-replacer"><a class="markdownIt-Anchor" href="#lru-k-replacer"></a> LRU-K Replacer</h2><p><strong>LRU-k evict policy</strong> 是让访问次数未到 k 的结点会被优先 evict 出去（这么做或许是为了防止一些微小的 <em>扰动访问</em> 污染了原来经常访问的区域），然后对于访问次数到达 k 次的结点则按照最近访问时间（或逻辑上的时间戳）最久远的被 evict。（实际上按照原始论文和 slides 上的意思应该是最近访问时间和第前 k 次访问时间<strong>之差</strong>相差最大的被 evict，但是按照前面的方法也过了。。。）</p><ul><li><a href="https://www.cs.cmu.edu/~natassa/courses/15-721/papers/p297-o_neil.pdf">LRU-k的原始论文</a></li><li><a href="https://leetcode.cn/problems/lru-cache/">leetcode上的lru算法</a>，不熟悉的可以先试试</li></ul><p>针对 LRU-k 算法，我实现了两种方法，简单说一下思路。</p><h3 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一</h3><p>维护两个链表，一个存未到 k 次访问的<code>frame_id</code>,另一个存已到（或超过）k 次访问的 <code>frame_id</code>，我们分别将其叫做 <code>history_list</code>以及<code>cache_list</code>。</p><p>同时维护一个从<code>frame_id</code>到 <code>FrameEntry</code>的哈希表，这个<code>FrameEntry</code>保存了<code>hit_count</code>，<code>evictible</code>以及一个list&lt;frame_id_t&gt;的迭代器。</p><ul><li><strong>Evict:</strong> 若 hist_list 非空，找到第一个 evictable 的 frame 将其踢出，否则找cache_list 中第一个evictable 的 frame。</li><li><strong>RecordAccess(frame_id):</strong>  通过 <code>FrameEntry</code> 查看 hit_count （1）若他是第一次访问，则将其放在 history_list 尾部，注意，同时还要维护这个 frame_id 在FrameEntry 中的迭代器 。（2）若 new_count == k 则在history_list中删去这个frame(无需遍历，通过保存在哈希表中的迭代器进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 删除)，添加到 cache_list 中，同时维护哈希表 （3）new_count &gt; k，将这个 frame_id 移动到 cache_list 最后（删除和添加都可以做到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ）</li><li><strong>SetEvictable</strong> 和 <strong>Remove</strong>都可以类似的操作。</li></ul><h3 id="方法一时间复杂度"><a class="markdownIt-Anchor" href="#方法一时间复杂度"></a> 方法一时间复杂度：</h3><p>假设 history_list 和 cache_list 中的元素个数都是 n， 两个队列中 non-evictable 的个数都为 m，则 Evict 的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>（最差遍历 m 个元素） 其余操作时间复杂度都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。需要注意的是，RecordAccess 要比 Evict 经常使用的多，且 Evict 遍历 m 个元素是在 non-evictable page 都在 evictable page 的先前访问。实际上可以看作一个常数。</p><h3 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二</h3><p>为了绝对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的 evict，我们可以使用std::set（红黑树），结点内部维护 <em>hit_count</em> 和 <em>到达时间</em>，需要重载&lt;=，就可以达到。但是这种做法不仅常数大（结点之间比较需要先比较访问了k次没有，对到达k次和没到达k次的结点还需分别比较），更致命的是它使得 <code>RecordAccess(frame_id)</code>的复杂度变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> （需要一次 find， 一次 delete，一次 insert）。</p><h2 id="summary"><a class="markdownIt-Anchor" href="#summary"></a> Summary</h2><p>这是四个实验（不算primer）中最简单的一个了，如果实在卡在某部分的话试试通过分析测试样例来得到预期行为，或者使用 gdb （可以使用 lldb 配合 vscode 代替命令行条件下进行调试）。相信我，越早学会如何调试对后面越有益。</p><p>最后当然是 AC 截图了</p><p><img src="../img/busTub/buffer_pool_manager/p1-result.png" alt="" /></p><h2 id="resources"><a class="markdownIt-Anchor" href="#resources"></a> Resources</h2><ul><li><a href="https://15445.courses.cs.cmu.edu/fall2022">课程官网</a></li><li><a href="https://github.com/cmu-db/bustub">Github Repo</a></li><li><a href="https://www.youtube.com/watch?v=uikbtpVZS2s&amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf&amp;ab_channel=CMUDatabaseGroup">Youtube课程视频 2022fall</a> （如果对英文字幕有压力的话可以在 chrome 插件里下个中英文双字幕插件）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>database</tag>
      
      <tag>cmu15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs144-note1</title>
    <link href="/cs144-note1/"/>
    <url>/cs144-note1/</url>
    
    <content type="html"><![CDATA[<h1 id="computer-network"><a class="markdownIt-Anchor" href="#computer-network"></a> Computer Network</h1><h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> introduction</h2><p>dominant model : bidirectional, reliable byte stream connection</p><ul><li><p><strong>http</strong>: hypertext transfer protocol : designed to be a document centric way for programs to communicate.<br />Client  —&gt;  Server  model</p></li><li><p><strong>Bit-Torrent</strong>: (peer-to-peer model) a client requests document from other clients, a single client can request from many others.<br />these collections of collaborating clients are called <strong>swarms</strong><br />when a client wants to downloads a file, it first find <code>torrent</code>, usually using www and download using http.<br /><strong>torrent</strong> file describes information about data file, also tells bit-torrent about the <strong>tracker</strong> (a node keeps track names of clients of the swarm)</p></li><li><p><strong>skype</strong>: client &lt;–NAT–&gt;client   two clients request data from each other</p><p><em>NAT</em> : network address translator<br />if you’re <em>behind a NAT</em>, you can open connections out to the internet, but other nodes on the internet can’t easily open connections to you.</p></li></ul><h2 id="the-4-layer-internet-model"><a class="markdownIt-Anchor" href="#the-4-layer-internet-model"></a> The 4 layer Internet Model</h2><h3 id="network-layer-and-link-layer"><a class="markdownIt-Anchor" href="#network-layer-and-link-layer"></a> Network layer and link layer</h3><img src = "../img/cs144/4LayerModel.png" align="left" width="300px" height="430"/><span style="float:left"></span> The Internet is made up of `event hosts`, `links` and `routers`. <p>data is delivered in <strong>packets</strong><br />a packet is a self-contained unit consisting of the data we want to be delivered.</p><p>link layer’s job is  to carry the data over one link  at a time.<br /><code>ethernet</code> and <code>wifi</code> --&gt; two examples of different links layers</p><p>Network layer’s job is to deliver packets end to end across the internet.<br /><strong>a packet is a collection data with header</strong>.<br /><img src = "../img/cs144/packet.png" align="right" width="380" height ="100px"/></p><p>network layer packet are called <code>datagram</code>.</p><p><img src="../img/cs144%5CNetwork_link.png" alt="" /></p><h3 id="the-network-layer-is-special"><a class="markdownIt-Anchor" href="#the-network-layer-is-special"></a> The network layer  is “special”</h3><p>we must use the internet Protocol (IP)</p><ul><li>IP makes a best-effort attempt to deliver our datagrams to the other end. <strong>But it make no promise</strong></li><li>IP datagrams can get lost, delivered out of order, and be corrupted. <strong>No guarantees</strong>.</li></ul><h3 id="transport-layer"><a class="markdownIt-Anchor" href="#transport-layer"></a> Transport layer</h3><p>the most common transport layer is <strong>TCP</strong> (transmission control protocol)</p><ul><li>guarantee correct in-order delivery of data</li></ul><p>some applications doesn’t need reliable delivery, it can use <strong>UDP</strong> (user datagram protocol).</p><ul><li>an alternative transport layer that bundles up application data and hands it to the network layer</li><li>it offers no delivery guarantees at all</li></ul><h3 id="application"><a class="markdownIt-Anchor" href="#application"></a> Application</h3><p>they have their own protocol to define the syntax and semantics of data flowing between two end points<br />(e.g. http, bit-torrent)</p><h3 id="others"><a class="markdownIt-Anchor" href="#others"></a> others</h3><img src = "../img/cs144/IP_is_thin.png" width="700px" height="350"/><img src = "../img/cs144/OSI-model.png" width="700px" height="350"/><h2 id="ip-service-model"><a class="markdownIt-Anchor" href="#ip-service-model"></a> IP Service model</h2><table><thead><tr><th>Property</th><th>behavior</th></tr></thead><tbody><tr><td>Datagram</td><td>Individually routed packets.</td></tr><tr><td>Unreliable</td><td>packet might be dropped</td></tr><tr><td>Best effort</td><td>only if necessary</td></tr><tr><td>Connectionless</td><td>No per-flow state.</td></tr></tbody></table><p><strong>IP is &quot;simple&quot;</strong></p><ul><li>faster, lower cost to build and maintain</li><li>The end-to-end principle</li><li>allows a variety of reliable (or unreliable) service to be built on top</li><li>make very few assumptions about link layer</li></ul><p><strong>IP Service Model</strong></p><ol><li>Tried to prevent packets looping forever<br />add a hop count field in the header of every datagram (<code>ttl</code>:time to live), start at a number like 128, decremented by every router passes through, when it reaches 0, IP think it be stuck in a loop then drop it.</li><li>will fragment packets if they are too long.<br />bc most links have a limit on the size of packets.(ethernet – 1500bytes)</li><li>uses a header checksum to reduce chances of delivering datagram to wrong destination.</li><li>allows for new version of IP<ul><li>IPv4     32 bit addresses</li><li>IPv6     128 bit addresses</li></ul></li><li>allows for new options to be added to header</li></ol><img src = "../img/cs144/IPv4-datagram.png"  width="500px" /><h2 id="life-of-a-packet"><a class="markdownIt-Anchor" href="#life-of-a-packet"></a> Life of a Packet</h2><h3 id="three-way-handshake"><a class="markdownIt-Anchor" href="#three-way-handshake"></a> three-way handshake</h3><ol><li><p>Client -----sends a synchronized message(同步信息)-----&gt; Server   (synchronize, <strong>SYN</strong>)</p></li><li><p>Server -----responds with a synchronized message and also acknowledges the client synchronize----&gt; Client   (synchronize and acknowledge, <strong>SYN/ACK</strong>)</p></li><li><p>Client -----responds by acknowledging the server synchronized ----&gt; Server   (acknowledge, <strong>ACK</strong>)</p></li></ol><p>IP addressed:  like computer addresses.<br />TCP port: tells which applications to deliver data to.</p><p>Web Server usually run on tcp port 80.</p><p><img src="../img/cs144/inside-the-stream.png" alt="" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>ComputerNetwork</tag>
      
      <tag>cs144</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
